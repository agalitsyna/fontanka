import click
import click_log
from . import cli

import pandas as pd
import numpy as np
import scipy

import cooler
from cooltools.api import snipping
from ..lib import *

# Set up logging:
from . import get_logger

logger = get_logger(__name__)


@cli.command()
@click_log.simple_verbosity_option(logger)
@click.argument("cool_path", metavar="COOL_PATH", type=str)
@click.argument("output_path", metavar="OUTPUT_PATH", type=str)
@click.option(
    "--regions",
    "--view",
    help="Regions table, tsv file with chromosome, start, end in each line, no header.",
    type=str,
)
@click.option(
    "--window-size", "-W", help="Window size for fountains, in basepairs", type=int,
)
@click.option(
    "--nthreads",
    "-p",
    help="Number of threads to use for generating snips",
    type=int,
    default=1,
)
@click.option(
    "--expected",
    help="File with expected table, generated by cooltools compute-expected.",
    type=str,
    default=None,
)
def slice_windows(cool_path, output_path, regions, window_size, nthreads, expected):
    """
    Slice windows for fountain calling.
    """

    logger.info(f"""Slicing {cool_path} with window size: {window_size}""")

    # load cooler
    clr = cooler.Cooler(cool_path)
    bins = clr.bins()[:]
    resolution_bp = clr.binsize

    assert (
        window_size % resolution_bp == 0
    ), "Window size should be divisible by resolution"

    # load chromosome regions
    chroms_regions = pd.read_table(regions, header=None)
    if len(chroms_regions.columns) == 3:
        chroms_regions.columns = ["chrom", "start", "end"]
        chroms_regions.loc[:, "name"] = chroms_regions.apply(
            lambda x: f"{x.chrom}:{x.start}-{x.end}", axis=1
        )
    elif len(chroms_regions.columns) == 4:
        chroms_regions.columns = ["chrom", "start", "end", "name"]
    else:
        raise ValueError(
            "Regions table should have 3 or 4 columns and no header. Comply with Open2C viewframe format."
        )

    # create genome-wide windows:
    windows = snipping.make_bin_aligned_windows(
        resolution_bp, bins["chrom"], bins["start"], flank_bp=window_size
    )

    # Assign genomic regions to windows:
    windows = snipping.assign_view_auto(windows, chroms_regions).reset_index(drop=True)

    # Create and store the stack:
    if not expected is None:
        expected = pd.read_table(expected, header=0)

    stack = generate_ObsExpSnips(
        clr, windows, chroms_regions, expected=expected, nthreads=nthreads
    )
    # Store the stack:
    save_snips(stack, output_path)

    logger.info(f"Finished generating stack, stack shape:{stack.shape} ")
    logger.info(f"Saved stack to {output_path}")
